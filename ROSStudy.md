

# ROS学习笔记

[TOC]

## 前言 

### 1、 虚拟机、ubuntun及ROS系统安装

1. [VMware17Pro虚拟机安装教程(超详细)-CSDN博客](https://blog.csdn.net/weixin_52799373/article/details/139041173)
2. [VMware虚拟机安装Ubuntu教程(超详细)_vmware安装ubuntu-CSDN博客](https://blog.csdn.net/weixin_52799373/article/details/139055794)
3. [详细介绍如何在ubuntu20.04中安装ROS系统，超快完成安装（最新版教程）_ubuntu安装ros-CSDN博客](https://blog.csdn.net/qq_44339029/article/details/120579608)

以上为初步进行虚拟机与ros系统搭建的环节，需要严格执行

### 2、ROS学习路线推荐

这里推荐一个[北京华清智能科技有限公司](http://www.autolabor.com.cn/)，这个公司出了一个系列教程，比较全。

还有B站的阿杰，适合快速入门

### 3、实操案例

1. 构图与导航实例：[基于ROS的机器人建图与导航仿真全过程](https://mp.weixin.qq.com/s/k4IXh5-vFbG7Ze-fJi5O3g)
2. 基于DRL中TD3算法的实例：https://zhuanlan.zhihu.com/p/709427766

## 一、ROS1与ROS2的操作与比较

### 1、Linux基本指令

<img src="D:\HuaweiMoveData\Users\高昕\Documents\WeChat Files\wxid_p3jhtid6trnh22\FileStorage\Temp\8c6f986246cbb93a02850fb292e238d.jpg" alt="8c6f986246cbb93a02850fb292e238d" style="zoom:50%;" />

### 2、ros1基本指令

<img src="D:\HuaweiMoveData\Users\高昕\Documents\WeChat Files\wxid_p3jhtid6trnh22\FileStorage\Temp\8745eda4f118d138a43ae21f894ac4d.jpg" alt="8745eda4f118d138a43ae21f894ac4d" style="zoom:50%;" />

### 3、ros2基本指令

### ROS1与ROS2比较

ROS1（Robot Operating System 1）和ROS2（Robot Operating System 2）是两个广泛使用的机器人操作系统，它们在架构、通信机制、实时性、安全性、兼容性和应用场景等方面存在显著差异。

#### 1. 架构与通信机制

- **ROS1**：
  - 基于主从架构，依赖于一个中心化的Master节点进行集中式通信管理（roscore）。
  - 使用TCPROS/UDPROS通信协议，基于自定义的ROS通信机制。
  - 主节点故障会导致整个网络失效。
- **ROS2**：
  - 基于去中心化的网络架构，取消了Master节点，采用DDS（Data Distribution Service）作为底层通信机制。
  - DDS是一种数据分发服务，支持多节点独立运行，提高了系统的鲁棒性和可扩展性。
  - 支持实时性、嵌入式、分布式和多操作系统（如Linux、Windows、Mac、RTOS等）。

#### 2. 实时性

- **ROS1**：
  - 不是为实时系统设计，缺乏对实时性的支持。
  - 缺少时间保证和优先级传递机制，适用于非实时性要求较高的研究和开发。
- **ROS2**：
  - 支持实时性能，通过DDS协议实现更好的实时性支持。
  - 支持QoS（Quality of Service）配置，确保关键任务的优先级和时间保证。

#### 3. 安全性

- **ROS1**：
  - 安全性不足，缺乏加密和认证机制。
  - 主节点的集中化管理增加了单点故障的风险。
- **ROS2**：
  - 引入了多种安全特性，如身份认证、加密通信和访问控制。
  - 支持多机器人系统和分布式计算，提高了系统的安全性和可靠性。

#### 4. 兼容性与平台支持

- **ROS1**：
  - 主要基于Linux系统，支持Ubuntu等发行版。
  - 编译和构建系统相对简单，但仅支持C++和Python两种编程语言。
- **ROS2**：
  - 支持多种操作系统，包括Linux、Windows、Mac、RTOS等，甚至可以在没有操作系统的裸机上运行。
  - 支持多种编程语言，如C++11、Python3.5+等。
  - 提供了更广泛的构建系统支持，如colcon。

#### 5. 应用场景

- **ROS1**：
  - 适用于学术研究、小型教育机器人和早期的工业应用。
  - 由于其集中式架构和有限的实时性支持，ROS1在复杂的工业环境中应用受限。
- **ROS2**：
  - 适用于工业自动化、智能交通、多机器人系统和嵌入式系统。
  - 支持实时处理和高可靠性要求的应用场景，如自动驾驶和医疗手术机器人。
  - 在多机器人协作和分布式计算方面具有显著优势。

#### 6、总结

ROS1和ROS2在架构、通信机制、实时性、安全性和兼容性等方面存在显著差异。ROS1更适合早期的研究和开发项目，特别是在学术界和小型机器人应用中。而ROS2则在工业应用、多机器人系统和嵌入式系统中表现出色，特别是在需要高实时性和安全性的场景中。随着技术的发展，ROS2逐渐成为主流选择，特别是在工业4.0和智能自动化领域。

## 二、节点、消息与服务

### **1. 节点（Node）——咖啡店的员工**

**形象例子**：
 想象一家咖啡店有3名员工：

- **收银员**（节点A）：负责接收顾客订单并传递给咖啡师。
- **咖啡师**（节点B）：根据订单制作咖啡，完成后通知服务员。
- **服务员**（节点C）：将咖啡送给顾客，并反馈顾客是否满意。

**技术解读**：

- 每个节点（员工）是独立的程序，专注于特定任务（收银、制作、配送）
- 节点通过ROS Master（类似“店长”）注册和协调通信。例如，咖啡师需要知道收银员的位置才能接收订单。
- 节点可以用不同语言编写（如Python收银员、C++咖啡师）。

------

### **2. 消息（Message）——订单便签条**

**形象例子**：
 顾客点了一杯卡布奇诺，收银员写下一张便签条（消息），内容包含：

- **咖啡类型**：字符串（"卡布奇诺"）
- **糖量**：浮点数（1.5勺）
- **是否加冰**：布尔值（False）

这张便签被贴在“订单栏”（Topic）上，咖啡师订阅该Topic并读取消息制作咖啡。

**技术解读**：

- 消息是严格定义的数据结构（如.msg文件），支持整型、字符串、数组等。
- 发布者（收银员）通过Topic（订单栏）发送消息，订阅者（咖啡师）监听Topic获取数据。
- 消息传递是异步的：咖啡师可以边做咖啡边接收新订单。

------

### **3. 服务（Service）——紧急补单请求**

**形象例子**：
 顾客突然要求将咖啡换成拿铁，服务员（客户端）向咖啡师（服务端）发起请求：

- **请求（Request）**：{咖啡类型: "拿铁"}
- **响应（Response）**：{成功: True, 耗时: 2分钟}

咖啡师完成制作后，服务连接立即断开（一次性交互）。

**技术解读**：

- 服务是同步通信，基于请求-响应模型（类似函数调用）。
- 服务定义在.srv文件中，包含请求和响应两部分数据结构。
- 与Topic不同，服务适用于需要即时反馈的场景（如机械臂紧急停止）。

### **总结对比表**

| **概念** | **生活比喻** |  **通信方式**  |         **典型场景**         |    **技术特性**    |
| :------: | :----------: | :------------: | :--------------------------: | :----------------: |
|   节点   |  咖啡店员工  |   无直接关联   | 独立任务执行（如传感器驱动） | 多语言、分布式运行 |
|   消息   |  订单便签条  | Topic发布/订阅 |  持续数据流（如摄像头图像）  |    异步、多对多    |
|   服务   | 紧急补单请求 | 服务请求/响应  |   一次性操作（如拍照指令）   |    同步、一对一    |

### **应用实例**

假设咖啡店用机器人送餐：

1. **节点**：导航算法节点（规划路径）、激光雷达节点（避障）。
2. **消息**：激光雷达通过Topic发送障碍物距离数据（`sensor_msgs/LaserScan`）。
3. **服务**：顾客点击“呼叫机器人”按钮，触发服务请求，机器人响应并移动到指定桌号。

### ROS1与ROS2在这三个进程中的使用区别

## 三、实用开发工具（rqt）

### 1、rqt 核心功能概述

rqt 是 ROS（机器人操作系统）中基于 *Qt 框架开发*的**图形化调试工具套件**，以插件形式提供多种可视化调试功能，支持灵活组合插件布局，适用于系统监控、数据分析、参数调优等场景。其核心功能包括：

- 模块化插件管理：通过插件机制集成多种工具（如节点拓扑图、日志查看、数据绘图等），可在同一窗口自由切换。
- 跨平台兼容性：支持 Linux、Windows 和 macOS 系统，与 ROS 版本（如 Noetic、Melodic、Galactic 等）深度集成。
- 实时动态交互：直接与 ROS 节点通信，实时显示传感器数据、调整参数、调用服务等。

### 2、常用 rqt 插件及指令

以下为 rqt 中最常用的插件及其功能指令：

#### 1. **系统通信拓扑可视化**

- **插件名**：`rqt_graph`功能:动态显示 ROS 节点（Node）、话题（Topic）、服务（Service）之间的连接关系，直观呈现数据流向。

- **启动指令**：

  ```bash
  rosrun rqt_graph rqt_graph  # 独立启动
  # 或在 rqt 主界面选择 Plugins -> Introspection -> Node Graph
  ```

#### 2. **日志管理与过滤**

- **插件名**：`rqt_console`

- **功能**：集中显示 ROS 节点的日志信息（DEBUG/INFO/WARN/ERROR/FATAL），支持按关键词过滤和高亮。

- **启动指令**

  ```bash
  rosrun rqt_console rqt_console
  ```

#### 3. **数据曲线绘制**

- **插件名**：`rqt_plot`

- **功能**：实时绘制发布在 Topic 上的数值型数据（如传感器读数、），支持多曲线叠加。

- **示例指令（绘制 IMU 角速度**）：

  ```bash
  rosrun rqt_plot rqt_plot /imu/data/angular_velocity/x /imu/data/angular_velocity/y
  ```

#### 4. **图像数据查看**

- **插件名**：`rqt_image_view`

- 功能：实时显示摄像头或图像处理节点的输出，支持多窗口对比和话题切换。

- **启动指令：**

  ```bash
  rosrun rqt_image_view rqt_image_view
  ```

#### 5. **参数动态调参**

- **插件名**：`rqt_reconfigure`

- 功能：可视化修改 ROS 节点的运行参数（如控制算法增益、滤波器阈值）。

- 启动指令：

  ```bash
  rosrun rqt_reconfigure rqt_reconfigure
  ```

#### 6.TF树查看

```bash
rosrun rqt_tf_tree rqt_tf_tree #会出错，原因是因为Ubuntu中安装了conda环境包名冲突，需要先执行“conda deactivate”
```



### 3、rqt 安装与基础指令

#### 1. **安装方法**

```bash
# Melodic 版本
sudo apt-get install ros-melodic-rqt ros-melodic-rqt-common-plugins
# Noetic 版本
sudo apt-get install ros-noetic-rqt ros-noetic-rqt-common-plugins
```

#### 2. **启动方式**

- 统一入口启动

  ```bash
  rqt  # 或 rosrun rqt_gui rqt_gui
  ```

  启动后通过菜单栏 

  ```
  Plugins
  ```

   选择所需插件。

- 独立插件启动

  ```bash
  rosrun rqt_<插件名> rqt_<插件名>  # 例如 rosrun rqt_plot rqt_plot
  ```

------

### 4、典型应用场景

#### 机器人运动调试

- 使用 

  ```
  rqt_plot
  ```

   监控电机速度反馈与目标值的跟踪曲线。

- 通过 

  ```
  rqt_graph
  ```

   检查导航节点与传感器节点的通信链路。

#### 视觉算法验证

- 利用 

  ```
  rqt_image_view
  ```

   对比原始图像与处理结果（如目标检测框）。

#### 系统异常排查

- 通过 

  ```
  rqt_console
  ```

   过滤 ERROR 级别日志，定位节点崩溃原因。

## 四、TF简介

### 1、TF树核心概念解析

TF树（Transform Tree）是ROS中用于管理多坐标系间变换关系的数据结构，其核心特点如下：

1. **树状层级结构**
   - 每个节点代表一个坐标系（如world、turtle1），边表示父子坐标系间的变换关系（平移+旋转）。所有坐标系必须通过树状路径连通，否则会报错。
   - 示例：在`turtle_tf`中，`world`为根节点，`turtle1`和`turtle2`作为子节点动态更新位置。
2. **动态与静态变换**
   - 静态变换（如雷达与底盘位置）通过static_transform_publisher发布；
   - 动态变换（如移动的乌龟）需持续更新位姿。
   - 所有变换通过/tf话题集中传输，消息类型为geometry_msgs/TransformStamped。
3. **数学基础**：使用4×4齐次矩阵描述坐标系变换，包含3D平移和旋转（四元数或欧拉角表示）。

------

### 2、TF树查看方法

#### 示例程序

```bash
roslaunch turtle_tf turtle_df_demo.launch
```

#### 1. **可视化工具**

**生成PDF结构图**

```bash
rosrun tf2_tools view_frames.py  # 生成frames.pdf文件[6,8](@ref)
```

示例输出：显示`world→turtle1`和`world→turtle2`的树状

 **RQT实时拓扑图**

```bash
rosrun rqt_tf_tree rqt_tf_tree  # 动态显示当前TF树[4](@ref)
```

**RVIZ 3D可视化**（这个很有意思）

```bash
rosrun rviz rviz -d $(rospack find turtle_tf)/rviz/turtle_rviz.rviz[7](@ref)
```

可观察坐标系箭头随乌龟移动的动态变化。

#### 2. **命令行工具**查看关系

```bash
rosrun tf tf_echo turtle1 turtle2  # 实时打印两坐标系间的平移和旋转[7](@ref)
```

#### 3、关系

$$T_{turtle1\_turtle2}=T_{turtle1\_world}*T_{turtle2\_world}$$

### 3、`turtle_tf`的与程序解读

#### 1. **Launch文件结构分析**

```xml
<launch>
  <!-- 启动乌龟仿真器 -->
  <node pkg="turtlesim" type="turtlesim_node" name="sim"/>
  <!-- 键盘控制节点 -->
  <node pkg="turtlesim" type="turtle_teleop_key" name="teleop"/>
  <!-- 乌龟1的TF广播器 -->
  <node name="turtle1_tf_broadcaster" pkg="turtle_tf" type="turtle_tf_broadcaster.py" args="turtle1"/>
  <!-- 乌龟2的TF广播器 -->
  <node name="turtle2_tf_broadcaster" pkg="turtle_tf" type="turtle_tf_broadcaster.py" args="turtle2"/>
  <!-- TF监听器（控制跟随） -->
  <node name="turtle_tf_listener" pkg="turtle_tf" type="turtle_tf_listener.py"/>
</launch>
```

关键组件：

- **仿真器**：提供基础环境。
- **广播器**：将乌龟的`Pose`消息转换为TF变换。
- **监听器**：计算turtle2→turtle1的变换，生成速度指令。

------

#### 2. **TF广播程序（C++示例）**

```cpp
// turtle_tf_broadcaster.cpp
void poseCallback(const turtlesim::PoseConstPtr& msg) {
  tf::Transform transform;
  transform.setOrigin(tf::Vector3(msg->x, msg->y, 0.0));  // 设置平移
  tf::Quaternion q;
  q.setRPY(0, 0, msg->theta);  // 欧拉角转四元数
  transform.setRotation(q);
  // 发布world→turtleX的变换
  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world", turtle_name));
}
```

- 功能：订阅乌龟位姿，持续广播其相对于world的变换。

------

#### 3. **TF监听程序（Python示例）**

```python
# turtle_tf_listener.py
listener.waitForTransform("/turtle2", "/turtle1", rospy.Time(0), rospy(4.0))
(trans, rot) = listener.lookupTransform("/turtle2", "/turtle1", rospy.Time(0))
# 计算线速度和角速度
vel_msg.angular.z = 4 * math.atan2(trans[1], trans[0])
vel_msg.linear.x = 0.5 * math.sqrt(trans[0]**2 + trans[1]**2)
turtle_vel.publish(vel_msg)
```

- 原理：通过lookupTransform

  获取两乌龟间的相对位姿，生成控制指令。

------

### 4、关键调试技巧

1. **TF树断裂排查**
2. - 使用tf_monitor检查未连接的坐标系。
   - 确保所有变换的时间戳一致，避免因时间不同步导致查找失败
3. **动态参数调整**
4. 通过`rqt_reconfigure`实时修改广播频率或变换参数。

## 五、SLAM

### 1、激光SLAM与视觉SLAM比较

#### a、激光SLAM与视觉SLAM对比

| **特性**       | **激光SLAM**                 | **视觉SLAM**                    |
| -------------- | ---------------------------- | ------------------------------- |
| **传感器**     | 激光雷达（LiDAR）            | 单目/双目/RGB-D相机             |
| **精度**       | 高精度（厘米级）             | 中等精度（依赖特征匹配）        |
| **环境适应性** | 受光照影响小，适应黑暗环境   | 依赖光照条件，动态物体敏感      |
| **计算资源**   | 中等（点云处理）             | 较高（图像特征提取/优化）       |
| **建图效果**   | 高精度2D/3D几何地图          | 稀疏/半稠密语义地图             |
| **典型算法**   | Gmapping, Cartographer, LOAM | ORB-SLAM, LSD-SLAM, VINS-Fusion |
| **应用场景**   | 室内导航、自动驾驶           | AR/VR、无人机、消费级机器人     |

---

#### b、算法选择建议

**可以优先选择激光SLAM的场景：**

1. *需要高精度几何地图的工业场景*
2. 光照条件复杂/黑暗环境
3. 实时性要求高的自动驾驶场景

**可以优先选择视觉SLAM的场景：**

1. 成本敏感的消费级产品
2. 需要语义理解的场景（如AR导航）
3. 重量/尺寸受限的移动平台（如无人机）

**推荐方案：**

```python
if 环境光照稳定且需要语义信息:
    选择VINS-Fusion或ORB-SLAM3
elif 高精度导航且预算充足:
    选择LIO-SAM（激光惯性融合方案）
else:
    采用Cartographer（激光+IMU多传感器融合）
```

#### c、性能优化技巧

**激光SLAM优化**

- 使用IMU进行运动补偿
- 调整体素滤波参数（leaf_size=0.1）
- 启用多分辨率地图

**视觉SLAM优化**

- 使用GPU加速特征提取
- 配置动态特征剔除阈值
- 启用回环检测线程

#### d、AI评估指标对比

| **指标**  | 激光SLAM典型值 | 视觉SLAM典型值 |
| --------- | -------------- | -------------- |
| 定位误差  | 0.1-0.3m       | 0.5-2.0m       |
| 建图频率  | 10-20Hz        | 5-15Hz         |
| CPU占用率 | 30-50%         | 50-80%         |
| 内存消耗  | 1-2GB          | 2-4GB          |

> 注：以上数据基于Intel i7-11800H处理器测试结果

### 2、常见激光算法

#### **1. Hector SLAM （主要运用障碍物点云配置）**

**算法实现原理**

1. 高斯牛顿扫描匹配
   - 核心通过**高斯牛顿迭代优化**对齐当前激光扫描与已有地图，最小化扫描点与地图的欧氏距离。
   - 代价函数定义为：

$$
\xi^* = \arg\min_{\xi} \sum_{i=1}^{n} \left[1 - M\left(T_{\xi}(p_i)\right)\right]^2
$$

其中，$T_{\xi}(p_i)$  $表示位姿变换，$$M$为栅格地图的概率值（0-1）。

- 通过雅可比矩阵计算位姿增量，迭代优化直至收敛。

1. **多分辨率地图分层**：
   - 构建多层级（如0.05m、0.1m、0.2m分辨率）的栅格地图，粗分辨率地图用于快速匹配初始位姿，细分辨率地图用于精确优化。
2. **无里程计依赖**：
   - 仅依赖激光雷达数据，通过连续帧的扫描匹配推算相对运动，无需IMU或轮式编码器数据。

**优点**

- **无需外部传感器**：适合无人机、手持设备等无法稳定获取里程计的场景。
- **快速响应**：高频率激光雷达下实时性较好。

**缺点**

- **依赖高频低噪雷达**：低频率或噪声大的雷达易导致匹配失败。
- **无回环检测**：长期运行累积误差无法消除。
- **动态环境鲁棒性差**：移动障碍物会导致地图错位。

------

#### **2. Gmapping (基于RBPF的SLAM//里程计+障碍物点云配置算法)**

**算法实现原理**

1. **Rao-Blackwellized粒子滤波 (RBPF)**：
   - 将SLAM分解为 **定位（粒子滤波）** 和 **建图（栅格地图更新）** 两个步骤。
   - 每个粒子表示一个可能的机器人轨迹，并维护对应的地图。
2. **提议分布优化**：
   - 采用**扫描匹配优化提议分布**，通过当前激光数据优化每个粒子的位姿，减少粒子数量需求（通常100个粒子即可）。
   - 提议分布公式：

$$
p(x_t | x_{t-1}, u_t, z_t) \approx \frac{p(z_t | x_t, m_{t-1}) p(x_t | x_{t-1}, u_t)}{\eta}
$$

其中 $$  u_t $$为里程计数据，$$ z_t$$ 为激光数据。

1. 自适应重采样

   ：

   - 根据粒子权重（归一化后）决定是否重采样，避免粒子退化。

**优点**

- **鲁棒定位**：融合里程计与激光数据，室内小场景精度高。
- **计算效率高**：优化后的粒子滤波在资源受限设备上表现良好。

**缺点**

- **依赖里程计质量**：里程计误差直接影响建图精度。
- **无回环检测**：大场景中地图无法闭合。
- **粒子退化风险**：长时间运行后粒子多样性下降，可能定位失败。

------

#### **3. Google Cartographer**

具体实操[Cartographer 3D建图与纯定位（在线建图、保存和纯定位）_cartographer定位-CSDN博客](https://blog.csdn.net/m0_58322903/article/details/127575676)

**算法实现原理**

1. **子图（Submap）构建**：
   - 将连续激光扫描数据积累为局部子图，每个子图通过 **扫描匹配（CSM）** 与当前位姿对齐。
   - 子图匹配采用 **分支定界算法（Branch-and-Bound）** 加速搜索，在离散位姿空间中快速找到最优解。
2. **全局优化与回环检测**：
   - 使用 **稀疏位姿调整（SPA）** 优化所有子图的全局一致性，通过回环检测约束修正累积误差。
   - 回环检测基于**多分辨率栅格地图匹配**，利用分支定界法加速。
3. **多传感器融合**：
   - 支持激光雷达、IMU、里程计等多传感器融合，通过卡尔曼滤波或图优化整合数据。

**优点**

- **高精度大场景建图**：回环检测与全局优化显著降低累积误差。
- **工程化设计**：模块化代码支持2D/3D扩展，适合工业应用。
- **多传感器兼容**：适应复杂环境（如无GPS的室内外混合场景）。

**缺点**

- **计算资源需求高**：实时优化大规模地图需要高性能CPU/GPU。
- **参数调优复杂**：子图大小、回环检测阈值等参数需精细调节。
- **小场景冗余**：相比Gmapping，小场景计算量更大但精度提升有限。

**算法对比总结**

| 特性           | Hector SLAM              | Gmapping                | Cartographer                   |
| -------------- | ------------------------ | ----------------------- | ------------------------------ |
| **核心方法**   | 高斯牛顿扫描匹配         | RBPF粒子滤波 + 扫描匹配 | 子图优化 + 分支定界 + 全局SPA  |
| **依赖传感器** | 仅激光雷达               | 激光雷达 + 里程计       | 激光雷达 + 可选IMU/里程计      |
| **回环检测**   | 不支持                   | 不支持                  | 支持（多分辨率匹配）           |
| **计算复杂度** | 低（无粒子滤波）         | 中（粒子数少时）        | 高（全局优化 + 回环检测）      |
| **适用场景**   | 无里程计、小规模静态环境 | 室内小场景、稳定里程计  | 大规模复杂环境、多传感器融合   |
| **实时性**     | 高（需高频雷达）         | 高（粒子数少时）        | 中（依赖硬件性能）             |
| **工程化程度** | 低（无回环，鲁棒性差）   | 中（适合嵌入式设备）    | 高（模块化设计，支持商业扩展） |

**应用场景建议**

- **Hector SLAM**：手持扫描设备、无人机等无里程计场景，需快速部署且环境静态。
- **Gmapping**：室内服务机器人、扫地机器人等小规模场景，配备可靠里程计。
- **Cartographer**：自动驾驶、仓储物流、大规模测绘等需高精度地图和回环检测的场景。



## 六、ROS中的navigation框架

### 全览<img src="D:\HuaweiMoveData\Users\高昕\Documents\WeChat Files\wxid_p3jhtid6trnh22\FileStorage\Temp\c54edd32869af63b04df9b8a03e8542.jpg" alt="c54edd32869af63b04df9b8a03e8542" style="zoom:50%;" />

下面这张图非常重要

<img src="D:\HuaweiMoveData\Users\高昕\Documents\WeChat Files\wxid_p3jhtid6trnh22\FileStorage\Temp\0304cdd3a6166b04421875946ac4aa2.jpg" alt="0304cdd3a6166b04421875946ac4aa2" style="zoom:67%;" />

### 1、系统架构总览

ROS Navigation Stack 是用于机器人自主导航的核心框架，基于模块化设计，主要包含以下核心节点和组件：

- **输入**：里程计（Odometry）、激光雷达/RGB-D 传感器数据、先验地图（可选）、坐标系变换（TF）

- **输出**：速度控制命令（`cmd_vel`)

- **核心节点**：`move_base`（全局/局部规划）、`map_server`（地图服务）、`amcl`（定位）

  

---

### 2、核心节点机制

1. **map_server**

- **功能**：提供静态地图（如SLAM生成的`.pgm`地图），通过`/map`话题发布`nav_msgs/OccupancyGrid`类型的地图数据。
- **关键配置**：需调整地图原点坐标（`origin`）和分辨率（`resolution`），确保与物理环境对齐。

2. **amcl（自适应蒙特卡洛定位）**

- **输入**：激光扫描数据（`/scan`）、初始位姿（`/initialpose`）、地图（`/map`）、里程计（/odom）。
- **输出**：机器人在地图中的估计位姿（`/amcl_pose`）、粒子云（`/particlecloud`）（算是机器人的一种分身，在具体的实操过程中通过比较不同分身的激光探测数据确定真实位置）以及`map`到`odom`的TF变换。
- **定位需求**：确定机器人在导航过程中的自身位置
- **定位原理**：基于粒子滤波算法，结合传感器数据与地图实现动态定位。*（算是机器人的一种分身，在具体的实操过程中通过比较不同分身（100-500）的激光探测数据确定真实位置——障碍物特征匹配/类比SLAM中用到的点云配准算法）*

3. **move_base（导航核心）**

- **功能模块**：
  - **全局规划器（global_planner）**  ：使用$A^*$(深度优先)或Dijkstra（广度优先）算法生成起点到目标的最优路径。负责从起点到终点的全局路径生成，使用静态地图（如`map_server`提供的地图）和`global_costmap`进行规划。
  - **局部规划器（local_planner）**  ：采用**DWA**（Dynamic Window Approach）或**TEB**（Timed Elastic Band）算法，实时避障并跟踪全局路径。根据实时传感器数据（如激光雷达`/scan`、IMU`/imu`）和`local_costmap`动态调整路径，避开障碍物。
  - **全局代价地图（global_costmap）**  ：基于先验地图生成，包含静态障碍物信息，用于全局路径规划。
  - **局部代价地图（local_costmap）**  ：动态更新传感器数据（如激光雷达），处理实时障碍物，用于局部路径调整。
  - **恢复行为（Recovery Behaviors）**  ：当路径规划失败时，执行旋转或清理代价地图等恢复策略。
  - 示意图：![[Pasted image 20250225204533.png]]

---

### 3、全局与局部地图对比（使用中互有补充）

| 特性         | 全局代价地图                     | 局部代价地图                 |
| ------------ | -------------------------------- | ---------------------------- |
| **数据来源** | 预先加载的静态地图（`/map`话题） | 实时传感器数据（如激光雷达） |
| **更新频率** | 低（仅在初始化时加载）           | 高（实时更新，通常10Hz以上） |
| **作用范围** | 覆盖整个环境                     | 限定在机器人周围（如5m×5m）  |
| **规划用途** | 全局路径规划（长距离）           | 局部避障与轨迹优化（短距离） |
| **典型算法** | A*、Dijkstra                     | DWA、TEB                     |

---

### 4、全局路径规划的两种算法的比较 

A*（深度优先）

Dijskra(广度优先)——大水漫灌

---

### 5、局部路径规划的两种算法的比较（DWA与TEB）[[机器人导航中常用的局部路径规划算法]]

**1. 核心算法思想**

- **DWA**（动态窗口法，同一时间内规划多条局部路径）：DWA通过在速度空间中采样多个速度组合，模拟可能的运动轨迹，并根据全局路径、障碍物等信息计算代价函数，选择代价最小的速度组合作为控制输入。其核心是动态窗口法，即在有限的速度范围内搜索最优速度组合，适用于单目标路径规划。  

  ![动态环境下基于改进DWA算法的AGV路径规划方法](https://oss.metaso.cn/metaso/thumbnail/0e9b10f90b0ad8a62ade4fee11933e09.jpg)

  动态环境下基于改进DWA算法的AGV路径规划方法

- **TEB**：TEB将路径视为一个弹性带，通过优化带状区域的形状和大小来调整路径，同时考虑动力学约束和时间约束。TEB的核心是优化路径的平滑性和避障能力，适合多目标路径规划。  

  ![一种基于改进TEB算法的AGV局部路径规划方法与流程](https://oss.metaso.cn/metaso/thumbnail/af7636f61b68eeaf23accd775905feb6.jpg)

  一种基于改进TEB算法的AGV局部路径规划方法与流程

2. **计算复杂度与执行效率**

- **DWA**：DWA的计算相对简单，通过速度采样和代价评估完成路径规划，适合实时性要求较高的场景。然而，其计算量随着速度窗口的增大而增加，且可能无法保证全局最优解。
- **TEB**：TEB的计算复杂度较高，因为它需要优化路径的平滑性和避障能力，同时处理动力学约束和时间约束。尽管如此，TEB通过引入图优化算法等技术降低了部分计算量。

**3. 适用场景与性能表现**

- **DWA**：
  - **优点**：计算简单，适合差分驱动和全向车模型；能够快速生成路径并适应动态障碍物。
  - **缺点**：前瞻性较短，难以处理复杂的避障场景；在动态障碍物较多的情况下表现不佳。
- **TEB**：
  - **优点**：具有较强的前瞻性，能够动态调整路径以避开障碍物；生成的路径更加平滑，适合复杂环境。
  - **缺点**：计算复杂度高，执行时间较长；在某些情况下可能出现局部优化问题。

4. 动态障碍物处理能力

- **DWA**：DWA在遇到动态障碍物时通常会减速以避免碰撞，但其避障效果有限，尤其是在复杂环境中。
- **TEB**：TEB通过预测未来路径并优化路径形状，能够更有效地避开动态障碍物。

5. 参数调整与优化

- **DWA**：DWA的参数调整主要集中在速度窗口大小、最小转弯半径等方面，适用于特定车型（如差分驱动车）。
- **TEB**：TEB的参数调整涉及弹性带宽度、时间间隔、动力学约束等，可以通过多线程并行优化进一步提升性能。

6. 性能对比

- 在安全性方面，DWA通常具有更高的安全距离，但在某些场景下可能无法及时避开障碍物。
- 在效率方面，TEB的路径规划时间较长，但生成的路径更加平滑且避障效果更好。
- 在平滑性方面，TEB的表现优于DWA，尤其是在复杂环境中，适应性更强，鲁棒性更轻

---

### 6、全局规划器、局部规划器以及自定义规划器

**关键参数配置**

- 全局代价地图参数：定义障碍物膨胀半径、地图层叠加方式等（`global_costmap_params.yaml`）。
- 局部代价地图参数：设置更新频率、传感器观测范围（`local_costmap_params.yaml`）[[16]]。
- 规划器参数：包括最大速度、加速度、目标容差等（如`base_local_planner_params.yaml`）。

**恢复行为（Recovery Behaviors）**

当机器人陷入死锁或路径被阻塞时，`move_base`按顺序执行以下恢复策略：

1. 清理局部代价地图：清除临时障碍物标记。
2. 旋转尝试：原地旋转以更新传感器数据。
3. 回退操作：沿原路径后退一定距离。

**典型数据流**

1. 初始化：`map_server`加载地图，`amcl`提供初始定位。
2. 全局规划：`global_planner`生成全局路径（`/global_plan`）。
3. 局部调整：`local_planner`结合实时传感器数据更新局部路径（`/local_plan`）。
4. 控制执行：速度命令通过`/cmd_vel`发送到底层驱动。

> 参考文档（[ROS Navigation Wiki](http://wiki.ros.org/navigation)）。
> ![[Pasted image 20250225204008.png]]
>
> ```
> 简易TF树
> map (全局地图基准)
> │
> └── odom (里程计参考系)
>     │
>     └── base_footprint/base_link (机器人本体)
>         │
>         ├── base_scan (激光雷达)
>         ├── camera_link (摄像头)
>         └── imu_link (IMU)
> ```
>



## 导航算法

### 1、A*算法实现



## 共勉
